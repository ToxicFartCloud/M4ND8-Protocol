# =====================================================================
# fnl_chk.yaml — Final Certification Checklist (v4.2)
# Purpose:
#   Supreme Law for ship/no-ship. Every check must pass unless explicitly
#   and narrowly waived in m4nd8_pro/spec.md with a signed rationale.
# Integration:
#   - Requires director.yaml v4.2 (with Escalation + log contract)
#   - Expects logs in ./_logs and worker logs at ./_logs/worker/*.log
#   - manifest.yaml may override verification_target
# Exit codes:
#   - Any failed check must exit non-zero.
# =====================================================================

version: "4.2"

defaults:
  verification_target: "pytest -q"
  worker_log_glob: "_logs/worker/*.log"
  action_plan_path: "_logs/action_plan.md"
  halt_alert_path: "_logs/HALT_ALERT.md"
  spec_path: "m4nd8_pro/spec.md"
  blueprint_path: "m4nd8_pro/blueprint.md"
  director_path: "m4nd8_pro/director.yaml"
  manifest_paths: ["m4nd8_pro/manifest.yaml","manifest.yaml"]
  policy_pack:
    - "m4nd8_pro/director.yaml"
    - "m4nd8_pro/manifest.yaml"
    - "m4nd8_pro/fnl_chk.yaml"
  # Files allowed to contain TEMPLATE-ONLY markers (master templates)
  template_marker_allowlist:
    - "m4nd8_pro/spec(template).md"
    - "m4nd8_pro/cofo.md"
    - "m4nd8_pro/hub.md"

# Optional dir → feature flag mapping (must match director.yaml)
optional_dir_flags:
  plugins: "features.plugins"
  adapters: "features.adapters"
  integrations: "features.integrations"
  dashboards: "features.dashboards"

checks:

  # --- Constitution / Policy Presence -------------------------------------------------
  - id: C00.policy_pack_present
    severity: critical
    rule: "Policy pack files must exist in repo."
    detect:
      files_exist:
        - "m4nd8_pro/director.yaml"
        - "m4nd8_pro/fnl_chk.yaml"
        - "m4nd8_pro/blueprint.md"
        - "m4nd8_pro/spec.md"

  # --- Template hygiene & Optional discipline ----------------------------------------
  - id: C11.optional_sections_omitted
    severity: high
    rule: "No (Optional) sections remain in final spec.md unless explicitly enabled."
    detect:
      file_regex_absent:
        file: "m4nd8_pro/spec.md"
        patterns:
          - "^##\\s+.*\\(Optional\\).*?$"

  - id: C12.template_markers_removed
    severity: high
    rule: "Template-only markers must not appear outside approved files."
    detect:
      script: |
        python - <<'PY'
        import glob, sys, pathlib, yaml
        try:
            cfg = yaml.safe_load(open("m4nd8_pro/fnl_chk.yaml","r",encoding="utf-8"))
            allow = set((cfg.get("defaults") or {}).get("template_marker_allowlist") or [])
        except:
            allow = []
        bad=[]
        for p in glob.glob("**/*.*", recursive=True):
          if ".git/" in p or p.endswith((".png",".jpg",".jpeg",".gif",".svg",".webp",".ico",".pdf",".zip",".tar",".gz",".7z",".exe",".dll",".so",".dylib",".bin",".lock")):
            continue
          try:
            text = pathlib.Path(p).read_text(encoding="utf-8", errors="ignore")
          except Exception:
            continue
          if "TEMPLATE-ONLY:" in text and p.replace("\\","/") not in allow:
            bad.append(p)
        if bad:
          print("Template markers found outside allowlist:", ", ".join(sorted(bad))); sys.exit(1)
        print("OK")
        PY

  - id: C13.usage_rules_removed
    severity: high
    rule: "The template Usage Rules block must not appear in final spec.md."
    detect:
      file_regex_absent:
        file: "m4nd8_pro/spec.md"
        patterns:
          - "^> ## Usage Rules"
          - "DELETE BEFORE FINAL"

  - id: C14.no_placeholders_left
    severity: high
    rule: "No TODO/TBD/example filler remains in shipped text."
    detect:
      grep_absent:
        pattern: "(?i)\\b(TODO|TBD|fill me|example placeholder)\\b"
        paths: ["**/*.md","**/*.yaml","**/*.yml","**/*.json"]

  - id: C15.scaffold_only_if_enabled
    severity: high
    rule: "Optional dirs exist only if corresponding feature flag is true."
    detect:
      script: |
        python - <<'PY'
        import os, yaml, sys
        flags={}
        for f in ("m4nd8_pro/manifest.yaml","manifest.yaml"):
          if os.path.exists(f):
            try: flags = (yaml.safe_load(open(f,"r",encoding="utf-8")) or {}).get("features",{}) or {}
            except Exception: flags={}
            break
        mapping = {"plugins":"plugins","adapters":"adapters","integrations":"integrations","dashboards":"dashboards"}
        bad=[d for d,flag in mapping.items() if os.path.isdir(d) and not flags.get(flag, False)]
        if bad:
          print("Optional dirs without feature flags:", ", ".join(bad)); sys.exit(1)
        print("OK")
        PY

  # --- Spec & Governance Integrity (v4.4 Upgrades) ----------------------------------
  - id: C16.agentic_tdd_mandate
    severity: critical
    rule: "spec.md must contain the Agentic TDD Mandate (§0.1)."
    detect:
      file_contains:
        file: "m4nd8_pro/spec.md"
        substrings: ["Agentic TDD Mandate", "RED", "GREEN", "REFACTOR"]

  - id: C17.reflexion_protocol
    severity: high
    rule: "spec.md must contain the Reflexion Protocol (§13.1)."
    detect:
      file_contains:
        file: "m4nd8_pro/spec.md"
        substrings: ["Reflexion Protocol", "Anti-Looping", "reflection.md"]

  - id: C18.worker_constraints
    severity: critical
    rule: "spec.md must contain Worker Constraints (§13)."
    detect:
      file_contains:
        file: "m4nd8_pro/spec.md"
        substrings: ["Worker Constraints", "Filesystem boundary", "Network egress"]

  # --- Read Order / Plan → Implement → Verify discipline -----------------------------
  - id: C20.read_order_respected
    severity: critical
    rule: "Worker logged reads in exact director-specified order (blueprint version)."
    detect:
      grep_present:
        pattern: "READ_OK: director.yaml → manifest.yaml → hub.md → cofo.md → spec.md → doctrine.md → fnl_chk.yaml"
        paths: ["_logs/worker/*.log"]

  - id: C21.plan_gate_respected
    severity: critical
    rule: "Plan → Implement → Verify order observed."
    detect:
      multi_grep_sequence:
        file_glob: "_logs/worker/*.log"
        ordered_patterns: ["^PLAN_OK$","^WRITE_OK\\:","^VERIFY_OK$"]

  - id: C22.action_plan_exists
    severity: high
    rule: "Action plan artifact exists and is non-empty."
    detect:
      file_nonempty: "_logs/action_plan.md"

  # --- Escalation protocol (HARD_STOP → ESCALATE) ------------------------------------
  - id: C30.halt_alert_on_hard_stop
    severity: critical
    rule: "Any HALT in logs must be accompanied by a structured HALT alert."
    detect:
      script: |
        python - <<'PY'
        import glob, os, sys, re
        logs = "\n".join(open(p,'r',encoding='utf-8',errors='ignore').read() for p in glob.glob("_logs/worker/*.log"))
        if re.search(r"^HALT:", logs, re.M):
          p = "_logs/HALT_ALERT.md"
          if not os.path.exists(p) or os.path.getsize(p) == 0:
            print("HALT seen, but _logs/HALT_ALERT.md missing or empty.")
            sys.exit(1)
        print("OK")
        PY

  # --- Environment and network sovereignty -------------------------------------------
  - id: C40.env_pinned
    severity: high
    rule: "All dependencies are pinned; lockfiles present when applicable."
    detect:
      script: |
        python - <<'PY'
        import os, sys
        bad=[]
        if os.path.exists('requirements.txt'):
          for line in open('requirements.txt','r',encoding='utf-8',errors='ignore'):
            s=line.strip()
            if s and not s.startswith('#') and '==' not in s and '@' not in s and 'git+' not in s:
              bad.append(f"requirements.txt:{s}")
        if bad:
          print("Unpinned dependencies:", ", ".join(bad)); sys.exit(1)
        print("OK")
        PY

  - id: C41.network_allowlist_strict
    severity: critical
    rule: "No wildcard egress; offline by default per director.yaml."
    detect:
      script: |
        python - <<'PY'
        import yaml, sys
        try:
            y = yaml.safe_load(open("m4nd8_pro/director.yaml","r",encoding="utf-8"))
            allow = (((y.get("environment") or {}).get("io_policies") or {}).get("network_allowlist") or [])
            if allow not in ([], None):
              if any(isinstance(x,str) and "*" in x for x in allow):
                print("Wildcard network allowlist entry detected:", allow); sys.exit(1)
        except FileNotFoundError:
            pass # Handled by C00
        print("OK")
        PY

  # --- Hub/Cofo discipline & filesystem boundaries -----------------------------------
  - id: C51.filesystem_boundary_respected
    severity: critical
    rule: "Writes occurred only inside director-declared boundaries."
    detect:
      script: |
        python - <<'PY'
        import yaml, glob, re, sys
        try:
            y = yaml.safe_load(open("m4nd8_pro/director.yaml","r",encoding="utf-8"))
            bounds = set((y.get("budgets") or {}).get("io",{}).get("filesystem_boundary",[]))
            logs = "\n".join(open(p,'r',encoding='utf-8',errors='ignore').read() for p in glob.glob("_logs/worker/*.log"))
            paths = re.findall(r"WRITE(?:_OK)?:\\s+(.+)", logs)
            bad=[p for p in paths if not any(p.startswith(b) for b in bounds)]
            if bad:
              print("Writes outside boundary:", ", ".join(bad)); sys.exit(1)
        except FileNotFoundError:
            pass
        print("OK")
        PY

  - id: C52.empty_or_unused_dirs_removed
    severity: medium
    rule: "No empty or stub-only directories remain."
    detect:
      script: |
        python - <<'PY'
        import os, sys
        skip={".git","node_modules","_logs","__pycache__",".venv","venv",".mypy_cache"}
        bad=[]
        for root, dirs, files in os.walk(".", topdown=True):
          if any(s in root for s in skip): continue
          if root != "." and not any(os.scandir(root)): bad.append(root)
        if bad:
          print("Empty directories:", ", ".join(sorted(bad))); sys.exit(1)
        print("OK")
        PY

  # --- Wiring Diagram (hub.md) validity ----------------------------------------------
  - id: C54.hub_wiring_valid
    severity: critical
    rule: "Each hub.md must contain a valid hub_wiring block; all referenced paths must exist; files in the folder are represented as nodes or explicitly listed in local_only."
    detect:
      script: |
        python - <<'PY'
        import os, re, sys, glob, yaml, pathlib

        def extract_yaml_block(md_text):
          blocks = re.findall(r"for b in blocks:
            if re.search(r"^\\s*hub_wiring\\s*:", b, flags=re.M):
              return b
          return None

        errors = []
        hubs = [p for p in glob.glob("**/hub.md", recursive=True)]
        for hub in hubs:
          text = pathlib.Path(hub).read_text(encoding="utf-8", errors="ignore")
          yblk = extract_yaml_block(text)
          if not yblk:
            errors.append(f"{hub}: missing hub_wiring block")
            continue
          try:
            data = yaml.safe_load(yblk) or {}
          except Exception as e:
            errors.append(f"{hub}: YAML parse error in hub_wiring: {e}")
            continue
          hw = (data.get("hub_wiring") or {})
          nodes = set(hw.get("nodes") or [])
          edges = hw.get("edges") or []
          local_only = set(hw.get("local_only") or [])

          base = os.path.dirname(hub) or "."
          # nodes must exist (unless external URL)
          for n in nodes:
            if isinstance(n, str) and not re.match(r"^[a-z]+://", n):
              if not os.path.exists(os.path.normpath(os.path.join(base, n.strip("./")))):
                errors.append(f"{hub}: node does not exist: {n}")

          # edges must have from/to in nodes (or be external URL) and a relation
          for i, e in enumerate(edges):
            f, t = e.get("from"), e.get("to")
            if not f or not t:
              errors.append(f"{hub}: edge #{i} missing from/to"); continue
            if "relation" not in e:
              errors.append(f"{hub}: edge #{i} missing relation")
            if not re.match(r"^[a-z]+://", str(f)) and f not in nodes:
              errors.append(f"{hub}: edge #{i} from not in nodes: {f}")
            if not re.match(r"^[a-z]+://", str(t)) and t not in nodes:
              errors.append(f"{hub}: edge #{i} to not in nodes: {t}")

          # Every file in the hub's own directory represented as node or local_only
          ignore = {"hub.md", "cofo.md", "README.md"}
          existing = set()
          for entry in os.listdir(base):
            if entry in ignore: continue
            p = "./" + entry
            existing.add(p)
          for f in sorted(existing):
            if f not in nodes and f not in local_only:
              errors.append(f"{hub}: {f} not represented in nodes or local_only")

        if errors:
          print("\\n".join(errors)); sys.exit(1)
        print("OK")
        PY

  # --- Cofo (ledger) discipline -------------------------------------------------------
  - id: C55.cofo_change_notes_present
    severity: critical
    rule: "Every file changed in the last commit has a cofo Change Note and a COFO_NOTE_OK log line."
    detect:
      script: |
        bash -lc '
          set -euo pipefail
          changed=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only)
          [ -z "$changed" ] && { echo "No changes detected; OK"; exit 0; }
          logs=$(cat _logs/worker/*.log 2>/dev/null || true)
          miss=0
          while IFS= read -r p; do
            d=$(dirname "$p"); cof="$d/cofo.md"
            echo "$logs" | grep -q "COFO_NOTE_OK: $p" || { echo "Missing COFO_NOTE_OK for $p"; miss=1; }
            [ -f "$cof" ] && grep -qE "\\|\\s*[^|]+\\s*\\|\\s*[^|]+\\s*\\|\\s*${p//\//\\/}\\s*\\|" "$cof" || { echo "Missing Change Note entry for $p in $cof"; miss=1; }
          done <<< "$changed"
          test $miss -eq 0 || exit 1
        '

  - id: C56.cofo_trace_reference_enforced
    severity: high
    rule: "Every cofo.md Change Note must include a Trace Reference to _logs/trace/."
    detect:
      script: |
        python - <<'PY'
        import glob, re, sys
        for cof in glob.glob("**/cofo.md", recursive=True):
            with open(cof, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            # Find Change Notes section
            notes_match = re.search(r"Change Notes.*?\n(\|.*?\|\n)+", content, re.DOTALL | re.IGNORECASE)
            if not notes_match:
                continue
            lines = notes_match.group(0).strip().split("\n")[2:]  # Skip header + separator
            for line in lines:
                if line.count("|") >= 6:  # At least 7 columns (Trace Ref is 7th)
                    cols = [c.strip() for c in line.split("|")[1:-1]]
                    if len(cols) >= 7 and not cols[6].startswith("_logs/trace/"):
                        print(f"Missing or invalid Trace Ref in {cof}: {line}")
                        sys.exit(1)
                else:
                    print(f"Change Note row has insufficient columns in {cof}: {line}")
                    sys.exit(1)
        print("OK")
        PY

  # --- Mock/Fake Isolation Enforcement --------------------------------------------
  - id: C57.mocks_isolated_to_test
    severity: critical
    rule: "Mocks, fakes, or stubs must live only in tests/ or mocks/ and be declared in cofo.md."
    detect:
      script: |
        python - <<'PY'
        import glob, re, sys, os
        # Find any file outside tests/ or mocks/ containing mock-like patterns
        for base in ["src", "lib", "app", "core", "infrastructure"]:
            if not os.path.isdir(base):
                continue
            for f in glob.glob(f"{base}/**/*", recursive=True):
                if not os.path.isfile(f) or not f.endswith(('.py','.js','.ts','.go')):
                    continue
                try:
                    txt = open(f, 'r', encoding='utf-8', errors='ignore').read()
                    if re.search(r"(?i)\b(mock|fake|stub)[_A-Za-z]*\b", txt):
                        print(f"Mock/fake detected outside test scope: {f}")
                        sys.exit(1)
                except Exception:
                    continue
        # Verify mocks in tests/ are declared in cofo.md
        for cof in glob.glob("**/cofo.md", recursive=True):
            with open(cof, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            # Ensure any mock file has a row with "mock" in Role or Description
            # (This is a lightweight check; full parsing is optional)
        print("OK")
        PY

  # --- Dependency Governance --------------------------------------------------------
  - id: C58.approved_dependencies_present
    severity: critical
    rule: "The Approved Dependency Base (approved_dependencies.db) must exist in .m4nd8/data/."
    detect:
      files_exist:
        - ".m4nd8/data/approved_dependencies.db"

  # --- Image integrity (spec-only images, no decoration) ------------------------------
  - id: C60.image_integrity
    severity: critical
    rule: "All images must be explicitly required by spec.md or cofo.md; no placeholders."
    detect:
      script: |
        python - <<'PY'
        import os, re, sys, glob
        declared=set()
        # collect declared image paths from spec/cofo files
        for p in ["m4nd8_pro/spec.md"] + [f for f in glob.glob("**/cofo.md", recursive=True)]:
          try:
            text=open(p,'r',encoding='utf-8',errors='ignore').read()
            declared.update(re.findall(r"(?:^|\\s)([\\w\\-/\\.]+\\.(?:png|jpg|jpeg|svg|webp|gif))", text, flags=re.I))
          except Exception: pass
        actual=set(glob.glob("**/*.png", recursive=True) + glob.glob("**/*.jpg", recursive=True) +
                   glob.glob("**/*.jpeg", recursive=True) + glob.glob("**/*.svg", recursive=True) +
                   glob.glob("**/*.webp", recursive=True) + glob.glob("**/*.gif", recursive=True))
        actual_norm={a.replace("\\\\","/").lstrip("./") for a in actual}
        declared_norm={d.replace("\\\\","/").lstrip("./") for d in declared}
        rogue=sorted(a for a in actual_norm if a not in declared_norm)
        if rogue:
          print("Undeclared images present:", ", ".join(rogue)); sys.exit(1)
        print("OK")
        PY

  # ====================================================================
  # Five Pillars of Enterprise Studio Final Certification
  # ====================================================================
  # 1) Security & Compliance
  - id: C100.no_secrets_in_code
    severity: critical
    rule: "No API keys, passwords, or secrets in source or logs."
    detect:
      script: |
        python - <<'PY'
        import os, re, sys, glob
        def files(globpat):
          return [p for p in glob.glob(globpat, recursive=True) if "/node_modules/" not in p and "/.git/" not in p and "/_logs/" not in p]
        pats = files("**/*.py")+files("**/*.js")+files("**/*.ts")+files("**/*.md")+files("**/*.env")+files("**/*.yaml")+files("**/*.yml")
        rx = re.compile(r"(?i)(api[_-]?key|password|secret|token|private.*key|aws[_-]*access|ssh.*key)")
        for f in pats:
          try:
            txt=open(f,'r',encoding='utf-8',errors='ignore').read()
            if rx.search(txt):
              print(f"Secret-like pattern in {f}"); sys.exit(1)
          except Exception: pass
        print("OK")
        PY

  - id: C101.dependency_vulns_scanned
    severity: critical
    rule: "No known CVEs in dependencies (via SCA)."
    detect:
      script: |
        bash -lc '
          set -e
          if [ -f requirements.txt ] && command -v pip-audit >/dev/null; then
            pip-audit --requirement requirements.txt
          else
            echo "Note: pip-audit not available or no requirements.txt; skip Python CVE scan" >&2
          fi
        '

  - id: C102.input_validation_present
    severity: high
    rule: "All public entrypoints validate inputs."
    detect:
      script: |
        python - <<'PY'
        import glob, sys
        py = " ".join(open(f,'r',encoding='utf-8',errors='ignore').read() for f in glob.glob("**/*.py", recursive=True))
        if "from fastapi" in py and "BaseModel" not in py:
          print("FastAPI detected but no Pydantic BaseModel for input validation"); sys.exit(1)
        print("OK")
        PY

  # 2) Code & Architecture Coherence
  - id: C110.no_dead_code
    severity: medium
    rule: "No unreachable or unused code (dead functions, vars)."
    detect:
      script: |
        bash -lc '
          if command -v vulture >/dev/null; then
            vulture src/ --min-confidence 80
          else
            echo "Note: vulture not installed; skipping dead-code scan" >&2
          fi
        '

  - id: C111.consistent_error_handling
    severity: high
    rule: "All error paths use structured logging, not print()."
    detect:
      script: |
        python - <<'PY'
        import glob, sys
        for f in glob.glob("src/**/*.py", recursive=True):
          t=open(f,'r',encoding='utf-8',errors='ignore').read()
          if "print(" in t and "logger." not in t:
            print(f"print() found in {f} without logger"); sys.exit(1)
        print("OK")
        PY

  - id: C112.layer_separation_enforced
    severity: medium
    rule: "Business logic not mixed with I/O or UI code."
    detect:
      script: |
        python - <<'PY'
        import glob, sys
        for f in glob.glob("src/core/**/*.py", recursive=True):
          if "requests" in open(f,'r',encoding='utf-8',errors='ignore').read():
            print(f"Network call in core layer: {f}"); sys.exit(1)
        print("OK")
        PY

  # 3) Functional Correctness
  - id: C120.edge_cases_tested
    severity: high
    rule: "Tests cover error paths, not just happy path."
    detect:
      script: |
        python - <<'PY'
        import glob, sys
        tests = glob.glob("tests/**/test_*.py", recursive=True)
        if not tests: print("No tests found"); sys.exit(1)
        content = " ".join(open(f,'r',encoding='utf-8',errors='ignore').read() for f in tests)
        if "assertRaises" not in content and "pytest.raises" not in content:
          print("No error-path tests detected"); sys.exit(1)
        print("OK")
        PY

  - id: C121.idempotency_verified
    severity: medium
    rule: "State-changing operations are idempotent where required."
    detect:
      manual: true

  # 4) Professional Polish
  - id: C130.no_debug_artifacts
    severity: critical
    rule: "No console.log, debugger, or dev-only config in prod."
    detect:
      script: |
        bash -lc '
          set -e
          if [ -d src ]; then
            ! grep -R "console\\.log" src/ 2>/dev/null || { echo "console.log in production code"; exit 1; }
            ! grep -R "debugger" src/ 2>/dev/null   || { echo "debugger statement found"; exit 1; }
          fi
        '

  - id: C131.license_and_copyright
    severity: high
    rule: "LICENSE present; source headers include copyright."
    detect:
      script: |
        python - <<'PY'
        import os, glob, sys
        if not os.path.exists("LICENSE"):
          print("LICENSE file missing"); sys.exit(1)
        for f in glob.glob("src/**/*.py", recursive=True):
          lines = open(f,'r',encoding='utf-8',errors='ignore').readlines()[:5]
          if not any(("Copyright" in l) or ("License" in l) for l in lines):
            print(f"Missing license header in {f}"); sys.exit(1)
        print("OK")
        PY

  - id: C132.docs_complete
    severity: medium
    rule: "README.md explains install, run, and config."
    detect:
      file_contains:
        file: "README.md"
        substrings: ["Installation","Usage","Configuration"]
        
  # --- Data Integrity & Anti-Hallucination (Project Veridical) ----------------
  - id: C200.no_hallucinated_identities
    severity: critical
    rule: "No hallucinated identities (Jane Doe, Acme Corp) allowed in production artifacts."
    detect:
      grep_absent:
        # Catches common fake names AI uses to fill space
        pattern: "(?i)(Jane Doe|John Doe|Acme Corp|Lorem Ipsum|TBD User|Dr\\. Kenji Tanaka|Maria Garcia)"
        paths: ["**/*.md", "**/*.json", "**/*.html", "**/*.pdf", "**/*.pptx"]

  - id: C201.no_hardcoded_mock_data
    severity: high
    rule: "Mock data arrays (>3 items) are forbidden in source. Must fetch from API."
    detect:
      script: |
        python - <<'PY'
        import glob, re, sys
        # Regex looks for arrays of objects with 'name:' and 'email:' repeated
        # This catches "const users = [{name: 'User 1'...}, {name: 'User 2'...}]"
        pattern = re.compile(r"(\{[^}]*name:.*email:.*\},?\s*){3,}")
        
        files = glob.glob("src/**/*.{js,ts,jsx,tsx,py}", recursive=True)
        bad_files = []
        
        for f in files:
            try:
                content = open(f, 'r', encoding='utf-8', errors='ignore').read()
                if pattern.search(content):
                    bad_files.append(f)
            except: pass
            
        if bad_files:
            print(f"Hardcoded mock data detected in: {', '.join(bad_files)}")
            sys.exit(1)
        print("OK")
        PY

  # 5) Build & Deployment Integrity
  - id: C140.reproducible_build
    severity: high
    rule: "Build produces identical artifacts on clean checkout."
    detect:
      manual: true

  - id: C141.cross_platform_ready
    severity: medium
    rule: "No hardcoded paths; uses pathlib/os.path.join."
    detect:
      script: |
        python - <<'PY'
        import glob, sys, re
        rx = re.compile(r"[\'\"][a-zA-Z]:\\\\|/tmp/|/var/")
        for f in glob.glob("src/**/*.py", recursive=True):
          if rx.search(open(f,'r',encoding='utf-8',errors='ignore').read()):
            print(f"Hardcoded path in {f}"); sys.exit(1)
        print("OK")
        PY

  - id: C142.lockfile_present
    severity: critical
    rule: "Exact dependency lockfile present (Pipfile.lock, package-lock.json, etc.)."
    detect:
      any_files_exist:
        - "Pipfile.lock"
        - "package-lock.json"
        - "poetry.lock"
        - "pnpm-lock.yaml"

  # --- Logit-Level Observability via Min-P Sampling -------------------------------
  - id: C170.minp_confidence_check
    severity: high
    rule: "Structured outputs include logits trace; critical tokens have P(token) >= 0.4."
    detect:
      script: |
        python - <<'PY'
        import os, sys, json, yaml, glob
        # Skip if feature not enabled
        mf = None
        for cand in ("m4nd8_pro/manifest.yaml", "manifest.yaml"):
            if os.path.exists(cand):
                mf = cand; break
        if mf:
            with open(mf) as f:
                features = (yaml.safe_load(f) or {}).get("features", {})
                if not features.get("structured_output_monitoring", False):
                    sys.exit(0)
        # Find all .json files that are not in _logs/ or node_modules/
        for json_path in glob.glob("**/*.json", recursive=True):
            if "_logs/" in json_path or "node_modules/" in json_path or json_path.endswith(".logits.json"):
                continue
            logits_path = json_path + ".logits.json"
            if not os.path.exists(logits_path):
                print(f"Missing logits trace for structured output: {json_path}")
                sys.exit(1)
            with open(logits_path) as f:
                logits = json.load(f)
            for token in logits:
                if isinstance(token, dict) and "prob" in token:
                    # Consider non-syntax tokens (values, not punctuation)
                    if token.get("token", "").strip() not in ("{", "}", "[", "]", ":", ",", "\"", ""):
                        if token["prob"] < 0.4:
                            print(f"Low-confidence hallucination risk in {json_path}: {token['token']} (P={token['prob']:.2f})")
                            sys.exit(1)
        print("OK")
        PY

  # --- Cryptographic Provenance via C2PA + Statistical Watermarking ------------------
  - id: C180.c2pa_provenance_chain
    severity: high
    rule: "All AI-generated artifacts include a C2PA manifest binding output to RAG sources."
    detect:
      script: |
        python - <<'PY'
        import os, sys, json, glob
        # Skip if feature not enabled
        mf = None
        for cand in ("m4nd8_pro/manifest.yaml", "manifest.yaml"):
            if os.path.exists(cand):
                mf = cand; break
        if mf:
            import yaml
            features = (yaml.safe_load(open(mf)) or {}).get("features", {})
            if not features.get("cryptographic_provenance", False):
                sys.exit(0)
        # Check for C2PA manifest in all .json, .pdf, .txt outputs
        for ext in ["json", "pdf", "txt"]:
            for f in glob.glob(f"**/*.{ext}", recursive=True):
                if "_logs/" in f or "node_modules/" in f:
                    continue
                # In real system, use c2pa-python to verify manifest
                # Here, we check for a placeholder file
                if not os.path.exists(f"{f}.c2pa"):
                    print(f"Missing C2PA manifest for {f}")
                    sys.exit(1)
        print("OK")
        PY

  condition: |
    (manifest.features.cryptographic_provenance == true) →
    (exists("src/manifest.c2pa") or exists("output/manifest.c2pa"))

C190:
  name: "intent_gating_enforced"
  description: "If features.intent_based_gating=true, Colang input rails must be defined"
  condition: "(manifest.features.intent_based_gating == true) → exists(\"policies/input_rails.colang\")"

C191:
  name: "cove_policy_declared"
  description: "If features.chain_of_verification=true, CoVe behavior must be documented in doctrine.md"
  condition: "(manifest.features.chain_of_verification == true) → contains(\"doctrine.md\", \"Chain of Verification (CoVe) Policy\")"

C192:
  name: "cove_rule_declared_in_spec"
  description: "spec(template).md must contain the Structured Data Integrity Rule"
  condition: "contains(\"spec(template).md\", \"Structured Data Integrity Rule (CoVe)\")"

  # --- UI Accessibility via Property-Based Testing ----------------------------------
  - id: C161.theme_contrast_pbt
    severity: high
    rule: "All design tokens meet minimum WCAG 2.2 AA contrast (4.5:1) for their intended use."
    detect:
      script: |
        python - <<'PY'
        import os, sys, json, re
        # Skip if UI not enabled
        mf = None
        for cand in ("m4nd8_pro/manifest.yaml", "manifest.yaml"):
            if os.path.exists(cand):
                mf = cand; break
        if mf:
            import yaml
            features = (yaml.safe_load(open(mf)) or {}).get("features", {})
            if not features.get("ui", False):
                sys.exit(0)
        # Run PBT if tokens exist
        if not os.path.exists("src/theme/tokens.json"):
            print("No UI tokens found; OK")
            sys.exit(0)
        # Check if PBT spec exists
        if not os.path.exists("tests/pbt/test_theme_contrast.py"):
            print("Missing PBT spec for theme contrast")
            sys.exit(1)
        # Optional: run the PBT
        print("OK")
        PY

  # --- PDS Tiering Enforcement -----------------------------------------------------
  - id: C160.pds_tier_compliance
    severity: high
    rule: "PDS Light allowed only for components marked core/stateless, stateless, and non-critical."
    detect:
      script: |
        python - <<'PY'
        import re, sys, pathlib
        spec = pathlib.Path("m4nd8_pro/spec.md").read_text(encoding="utf-8")
        # Find component table
        table_match = re.search(r"(\| name.*?\|.*?\|\n(?:\|.*?\|\n)+)", spec, re.DOTALL)
        if not table_match:
            sys.exit(0)  # Skip if no table (e.g., early project)
        lines = table_match.group(1).strip().split("\n")[2:]  # skip header + separator
        for line in lines:
            cols = [c.strip() for c in line.split("|")[1:-1]]
            if len(cols) < 10: continue
            name, comp_type, role, inputs, outputs, crit_path, uniq_ip, slo, owns_state, core_flag = cols[:10]
            is_light = comp_type.lower() == "core/stateless"
            is_stateless = owns_state.lower() == "n"
            is_noncrit = crit_path.lower() == "n"
            has_no_ip = uniq_ip.lower() == "n"
            if is_light and not (is_stateless and is_noncrit and has_no_ip):
                print(f"PDS Light violation: {name} is marked core/stateless but fails state/critical/IP check")
                sys.exit(1)
        print("OK")
        PY

  # --- Runtime Backend Enforcement (Conditional) -----------------------------------
  - id: C150.backend_real_not_mock
    severity: critical
    rule: "Real backend must be running; mocks forbidden when has_backend=true."
    detect:
      script: |
        python - <<'PY'
        import os, sys, yaml
        mf = [p for p in ("m4nd8_pro/manifest.yaml","manifest.yaml") if os.path.exists(p)]
        if not mf: sys.exit(0)  # skip if no manifest
        has_backend = (yaml.safe_load(open(mf[0])) or {}).get("features",{}).get("has_backend", False)
        if not has_backend: sys.exit(0)  # skip if feature disabled
        os.execv(sys.executable, [sys.executable, "-m", "sentinels.check_real_backend"])
        PY

  - id: C151.no_mock_in_codebase
    severity: high
    rule: "No mock backend classes or functions permitted in source."
    detect:
      grep_absent:
        pattern: "(?i)class.*Mock.*Backend|def.*mock_.*backend"
        paths: ["src/", "tests/"]

  # --- Tests / Verification -----------------------------------------------------------
  - id: C70.verification_target_green
    severity: critical
    rule: "verification_target runs and passes (project-agnostic, manifest-aware)."
    detect:
      script: |
        bash -s <<'BASH'
        set -euo pipefail

        # Locate manifest
        manifest=""
        [ -f m4nd8_pro/manifest.yaml ] && manifest="m4nd8_pro/manifest.yaml"
        [ -z "$manifest" ] && [ -f manifest.yaml ] && manifest="manifest.yaml"

        # Extract verification_target via Python heredoc (safe)
        target_cmd=""
        if [ -n "$manifest" ]; then
          target_cmd=$(python3 <<'PY'
        import sys, yaml, shlex
        p = sys.argv[1]
        try:
            with open(p, 'r', encoding='utf-8') as f:
                d = yaml.safe_load(f) or {}
            vt = d.get('verification_target')
            if isinstance(vt, str):
                print(vt)
            elif isinstance(vt, (list, tuple)):
                print(' '.join(shlex.quote(str(x)) for x in vt))
        except Exception as e:
            sys.exit(1)
        PY
                  "$manifest")
        fi

        # Fallbacks
        try_run() { echo "Running: $*"; eval "$@"; }
        exists() { command -v "$1" >/dev/null 2>&1; }

        if [ -z "$target_cmd" ]; then
          if [ -f Makefile ] && grep -qE "^(verify|verify:)" Makefile; then
            target_cmd="make verify"
          elif [ -f Makefile ] && grep -qE "^(test|test:)" Makefile; then
            target_cmd="make test"
          elif [ -x ./scripts/verify.sh ]; then
            target_cmd="./scripts/verify.sh"
          elif [ -f pytest.ini ] || [ -d tests ]; then
            exists pytest && target_cmd="pytest -q"
          elif [ -f package.json ]; then
            target_cmd="npm test --silent"
          fi
        fi

        if [ -z "$target_cmd" ]; then
          echo "No verification_target set and no usable fallback found." >&2
          echo "Set one in manifest.yaml or provide: make verify/test, ./scripts/verify.sh, pytest, or npm test." >&2
          exit 1
        fi

        # Preflight check
        first_tok="$(printf "%s" "$target_cmd" | awk '{print $1}')"
        case "$first_tok" in
          make|npm|pnpm|yarn) : ;;
          ./*) [ -x "$first_tok" ] || { echo "Not executable: $first_tok" >&2; exit 1; } ;;
          *) command -v "$first_tok" >/dev/null 2>&1 || { echo "Command not found: $first_tok" >&2; exit 1; } ;;
        esac

        echo "Running: $target_cmd"
        eval "$target_cmd"
        BASH
        
  # --- Misc safety & quality ----------------------------------------------------------

  - id: C90.no_large_binary_in_src
    severity: medium
    rule: "No large binaries (>5MB) live inside source directories."
    detect:
      script: |
        bash -s <<'BASH'
        set -euo pipefail
        if [ -d src ]; then
          mkdir -p _logs
          find src -type f -size +5M -print | tee _logs/large_bins.txt | (! grep -q .) || { echo "Large binaries in src (see _logs/large_bins.txt)"; exit 1; }
        fi
        BASH

  - id: C91.license_present_if_public
    severity: low
    rule: "If repo is public, LICENSE must be present."
    detect:
      script: |
        bash -s <<'BASH'
        if [ -d .git ] && git config --get remote.origin.url | grep -qiE "(github\.com|gitlab\.com)"; then
          test -f LICENSE || { echo "Public repo needs LICENSE"; exit 1; }
        fi
        BASH
        
# =====================================================================
# End of checks. Every failing check must block release.
# =====================================================================
